# Study

Questions I missed, things I need to pay attention to, study, or otherwise practice.

## 2020

### Compound Assignment Operators
```
int x = 12;
int x += 2.6;
```

Compound assignment operators  

### Octal Literals

Octal Literals are defined by a zero prefix.

```
012 + 021 = ?
012 = 8 + 2 = 10
021 = 16 + 1 = 17
10 + 17 = 27
```

Decimal literals are defined in traditional form, 0-9 in base 10.

Hexadecimal literals are defined with the *case insensitive* character set `a-fA-F0-9` and prefixed with `0x` or `0X`.

`0xFace = 61440 + 2560 + 192 + 14 = 64206`

Binary literals are defined with a `0b` or `0B` prefix.

`0b10101 = 16 + 4 + 1 = 21`

### Return Types

Check **return type** of methods!

### Binary Search Trees

Become familiar with how Binay Search Trees are created, and how one can manipulate them to create and level of elements.

More specifically, how many levels can a 32 element tree have if maximized?

Additionally, study **Min Heap**, **Max Heap**, **Complete Trees**, **Perfect Trees**,  **Strict Trees**, **Balanced Trees**,   **BST Trees**, and what a **Child Node** and **Leaf Node** is.

* Min Heap
    * Every node's child nodes are greater or equal to itself (i.e. smaller nodes higher up).
    * Binary Tree is complete.
* Max Heap
    * Every node's child nodes are less than or equal to itself (i.e. greater nodes higher up).
    * Binary Tree is complete.
* Complete Trees
    * 
* Perfect Trees
* Strict Trees
* Balanced Trees
* BST Trees
* Child Node
* Leaf Node

### String.split Trailing Strings

String.split will create empty strings, but trailing empty strings will not be included in the final array. Additionally, a integer can be appended to define a limit to the number of "splits" that will occur.

```java
out.println("xxOOxx".split("x"));
> ["", "", "00"]
out.println("xxx".split("x"));
> ["", "", ""]
out.println("xx0x0x0x".split("x"));
> ["", "", "0", "0", "0"]
out.println("xx0x0x0x".split("x", 3));
> ["", "", "0", "0x0x"]
```

### Java's Primary Four OOP Concepts

* Abstraction
    * Complex objects are given relatively simple forms. Complex code is hidden within a much simpler face. Code is rewritten less.
* Encapsulation
    * Fields are kept private. Getters and Setters are used to access values within objects.
* Inheritance
    * Classes can use features and attributes from previously defined classes so as to not repeat code, and add customized implementations of code.
* Polymorphism
    * Includes Method Overloading and Overriding
    * Method Overloading
        * A method may perform differently based on how it is called (i.e. different return type given different arguments).
        ```java
        int calculate(int val)
        double calculate(int val)
        double calculate(int val, int limit)
        ```
    * Method Overriding
        * Uses Polymorphism to *override* the functionality of a parent class's methods.
        ```java
        class Person {
            void live() {e}
            void tick() {
                this.live()
            }
        }

        class Student extends Person {
            void study() {}
            void tick() {
                this.study()
                super.tick(); // Calls Person.tick()
            }
        }
        ```